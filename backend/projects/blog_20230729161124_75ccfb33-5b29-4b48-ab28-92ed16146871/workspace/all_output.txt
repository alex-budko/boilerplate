Based on the assumptions made, here is the proposed architecture for the 'blog' program:

1. `blog.py` (Entrypoint file)
   - This file will serve as the entrypoint for the program.
   - It will handle the routing and request handling for the blog application.

2. `blog_controller.py`
   - This file will contain the controller class responsible for handling the blog-related operations.
   - It will have methods for creating, editing, and deleting blog posts, as well as retrieving blog posts.

3. `blog_post.py`
   - This file will define the data structure for a blog post.
   - It will contain a class representing a blog post, with attributes such as title, content, author, and creation date.

4. `blog_view.py`
   - This file will define the view class responsible for rendering the blog posts to the user.
   - It will have methods for displaying the list of blog posts, as well as individual blog posts.

Now, let's proceed with creating the content of each file.

`blog.py`
```python
from blog_controller import BlogController

if __name__ == "__main__":
    controller = BlogController()
    controller.run()
```

`blog_controller.py`
```python
from blog_post import BlogPost
from blog_view import BlogView

class BlogController:
    def __init__(self):
        self.blog_posts = []
        self.view = BlogView()

    def create_post(self, title, content, author):
        post = BlogPost(title, content, author)
        self.blog_posts.append(post)

    def edit_post(self, post_id, title, content):
        post = self.get_post_by_id(post_id)
        if post:
            post.title = title
            post.content = content

    def delete_post(self, post_id):
        post = self.get_post_by_id(post_id)
        if post:
            self.blog_posts.remove(post)

    def get_post_by_id(self, post_id):
        for post in self.blog_posts:
            if post.id == post_id:
                return post
        return None

    def get_all_posts(self):
        return self.blog_posts

    def run(self):
        while True:
            choice = self.view.display_menu()
            if choice == "1":
                title = self.view.get_input("Enter post title: ")
                content = self.view.get_input("Enter post content: ")
                author = self.view.get_input("Enter post author: ")
                self.create_post(title, content, author)
            elif choice == "2":
                post_id = self.view.get_input("Enter post ID to edit: ")
                title = self.view.get_input("Enter new title: ")
                content = self.view.get_input("Enter new content: ")
                self.edit_post(post_id, title, content)
            elif choice == "3":
                post_id = self.view.get_input("Enter post ID to delete: ")
                self.delete_post(post_id)
            elif choice == "4":
                self.view.display_posts(self.get_all_posts())
            elif choice == "5":
                break
            else:
                self.view.display_message("Invalid choice. Please try again.")
```

`blog_post.py`
```python
from dataclasses import dataclass
from datetime import datetime

@dataclass
class BlogPost:
    id: int
    title: str
    content: str
    author: str
    created_at: datetime = datetime.now()
```

`blog_view.py`
```python
class BlogView:
    def display_menu(self):
        print("1. Create a new post")
        print("2. Edit a post")
        print("3. Delete a post")
        print("4. View all posts")
        print("5. Exit")
        return input("Enter your choice: ")

    def get_input(self, prompt):
        return input(prompt)

    def display_message(self, message):
        print(message)

    def display_posts(self, posts):
        for post in posts:
            print(f"ID: {post.id}")
            print(f"Title: {post.title}")
            print(f"Content: {post.content}")
            print(f"Author: {post.author}")
            print(f"Created At: {post.created_at}")
            print("--------------------")
```

This architecture follows a simple MVC (Model-View-Controller) pattern, where the controller handles the business logic, the view handles the user interface, and the model represents the data structure for a blog post.

Please note that this is a simplified implementation and may not include all the features or error handling that a real-world blog application would require.